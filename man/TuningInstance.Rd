% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TuningInstance.R
\docType{data}
\name{TuningInstance}
\alias{TuningInstance}
\title{TuningInstance Class}
\format{\link[R6:R6Class]{R6::R6Class} object.}
\description{
Specifies a general tuning scenario, including performance evaluator and archive for Tuners to
act upon. This class encodes the black box objective function,
that a \link{Tuner} has to optimize. It allows the basic operations of querying the objective
at design points (see \code{$eval_batch()}), storing the evaluated point in an internal archive
and querying the archive (see \code{$archive()}).

Evaluations of hyperparameter configurations are performed in batches by calling \code{\link[mlr3:benchmark]{mlr3::benchmark()}} internally.
After a batch is evaluated, the \link{Terminator} is queried for the remaining budget.
If the available budget is exhausted, an exception is raised, and no further evaluations can be performed from this point on.
}
\section{Construction}{
\preformatted{pe = TuningInstance$new(task, learner, resampling, measures, param_set, terminator, bm_args = list())
}

This defines the resampled performance of a learner on a task, a feasibility region
for the parameters the tuner is supposed to optimize, and a termination criterion.
\itemize{
\item \code{task} :: \link[mlr3:Task]{mlr3::Task} | \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{learner} :: \link[mlr3:Learner]{mlr3::Learner} | \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{resampling} :: \link[mlr3:Resampling]{mlr3::Resampling} | \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{measures} :: list of \link[mlr3:Measure]{mlr3::Measure} | \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{param_set} :: \link[paradox:ParamSet]{paradox::ParamSet}\cr
Hyperparameter search space.
\item \code{terminator} :: \link{Terminator}.
\item \code{bm_args} :: named \code{list()}\cr
Further args for \code{\link[mlr:benchmark]{mlr::benchmark()}}.
}
}

\section{Fields}{

\itemize{
\item \code{task} :: \link[mlr3:Task]{mlr3::Task}.
\item \code{learner} :: \link[mlr3:Learner]{mlr3::Learner}.
\item \code{resampling} :: \link[mlr3:Resampling]{mlr3::Resampling}.
\item \code{measures} :: list of \link[mlr3:Measure]{mlr3::Measure}.
\item \code{param_set} :: \link[paradox:ParamSet]{paradox::ParamSet}.
\item \code{terminator} :: \link{Terminator}.
\item \code{bmr} :: \link[mlr3:BenchmarkResult]{mlr3::BenchmarkResult}\cr
A benchmark result, container object for all performed \link[mlr3:ResampleResult]{mlr3::ResampleResult}s when evaluating hyperparameter configurations.
\item \code{n_evals} :: \code{integer(1)}\cr
Number of configuration evaluations stored in the container.
\item \code{start_time} :: \code{POSIXct(1)}\cr
Time the tuning / evaluations were started.
This is set in the beginning of \code{tune} of \link{Tuner}.
}
}

\section{Methods}{

\itemize{
\item \code{eval_batch(dt)}\cr
\code{\link[data.table:data.table]{data.table::data.table()}} -> \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Evaluates all hyperparameter configurations in \code{dt} through resampling, where each configuration is a row, and columns are scalar parameters.
Returns a \code{data.table()} with corresponding rows, where each column is a named measure.
After a batch-eval the \link{Terminator} is checked, if it is positive, an exception of class \code{terminated_message} is raised.
This function should be internally called by the tuner.
\item \code{best(measure = NULL, ties_method = "random")}\cr
(\link[mlr3:Measure]{mlr3::Measure} | \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}, \code{character(1)}) -> \link[mlr3:ResampleResult]{mlr3::ResampleResult}\cr
Queries the \link[mlr3:BenchmarkResult]{mlr3::BenchmarkResult} for the best \link[mlr3:ResampleResult]{mlr3::ResampleResult} according \code{measure} (default is the first measure in \code{$measures}).
\code{ties_method} can be "first", "last" or "random" (c.f. \code{\link[mlr3misc:which_max]{mlr3misc::which_max()}}).
\item \code{archive(unnest = TRUE)}
\code{logical(1)} -> \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Returns a table of contained resample results, similar to the one returned by \code{\link[mlr3:benchmark]{mlr3::benchmark()}}'s
\code{$aggregate()} method. If \code{unnest} is \code{TRUE}, hyperparameter settings are stored in
separate columns instead of inside a list column.
}
}

\examples{
library(mlr3)
library(paradox)
library(data.table)
# Object required to define the performance evaluator:
task = tsk("iris")
learner = lrn("classif.rpart")
resampling = rsmp("holdout")
measures = msr("classif.ce")
param_set = ParamSet$new(params = list(
  ParamDbl$new("cp", lower = 0.001, upper = 0.1),
  ParamInt$new("minsplit", lower = 1, upper = 10)))

terminator = TerminatorEvals$new(5)
inst = TuningInstance$new(
  task = task,
  learner = learner,
  resampling = resampling,
  measures = measures,
  param_set = param_set,
  terminator = terminator
)

# first 4 points as cross product
design = CJ(cp = c(0.05, 0.01), minsplit = c(5, 3))
inst$eval_batch(design)
inst$archive()

# try more points, catch the eventually raised terminated message
tryCatch(
  inst$eval_batch(data.table(cp = 0.01, minsplit = 7)),
  terminated_message = function(e) message(as.character(e))
)

# try another point although the budget is now exhausted
tryCatch(
  inst$eval_batch(data.table(cp = 0.01, minsplit = 9)),
  terminated_message = function(e) message(as.character(e))
)

inst$archive()
}
\concept{TuningInstance}
\keyword{datasets}
