% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TuningInstance.R
\docType{data}
\name{TuningInstance}
\alias{TuningInstance}
\title{TuningInstance Class}
\format{\link[R6:R6Class]{R6::R6Class} object.}
\description{
Specifies a general tuning scenario, including performance evaluator and archive for Tuners to
act upon. This class encodes the black box objective function,
that a \link{Tuner} has to optimize. It allows the basic operations of querying the objective
at design points (see \code{eval_batch}), storing the evaluated point in an internal archive
and querying the archive (see \code{archive}).

Evaluations of HP configurations are performed in batches by calling \link[mlr3:benchmark]{mlr3::benchmark} internally,
and after a batch-eval, if the \link{Terminator} is positive, an exception is raised.
No further evaluations can be performed from this point on.
}
\section{Construction}{
\preformatted{pe = TuningInstance$new(task, learner, resampling, measures, param_set, terminator, bm_args = list())
}

This defines the resampled performance of a learner on a task, a feasibility region
for the parameters the tuner is supposed to optimize, and a termination criterion.
\itemize{
\item \code{task} :: \link[mlr3:Task]{mlr3::Task}.
See also \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{learner} :: \link[mlr3:Learner]{mlr3::Learner}.
See also \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{resampling} :: \link[mlr3:Resampling]{mlr3::Resampling}.
See also \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{measures} :: list of \link[mlr3:Measure]{mlr3::Measure}.
See also \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{param_set} :: \link[paradox:ParamSet]{paradox::ParamSet}.
\item \code{terminator} :: \link{Terminator}.
\item \code{bm_args} :: \code{list}\cr
Further args for \link[mlr:benchmark]{mlr::benchmark}.
}
}

\section{Fields}{

\itemize{
\item \code{task} :: \link[mlr3:Task]{mlr3::Task}\cr
\item \code{learner} :: \link[mlr3:Learner]{mlr3::Learner}\cr
\item \code{resampling} :: \link[mlr3:Resampling]{mlr3::Resampling}\cr
\item \code{measures} :: list of \link[mlr3:Measure]{mlr3::Measure}\cr
\item \code{param_set} :: \link[paradox:ParamSet]{paradox::ParamSet}\cr
\item \code{terminator} :: \link{Terminator}\cr
\item \code{bmr} :: \link[mlr3:BenchmarkResult]{mlr3::BenchmarkResult}\cr
A benchmark result, container object for all performed \link{ResampleResult}s when evaluating HP configurations.
\item \code{n_evals} :: \code{integer(1)}\cr
Number of configuration evaluations stored in the container.
\item \code{start_time} :: \code{POSIXct(1)}\cr
Time the tuning / evaluations were started.
This is set in the beginning of \code{tune} of \link{Tuner}.
}
}

\section{Methods}{

\itemize{
\item \code{eval_batch(dt)}\cr
\code{\link[data.table:data.table]{data.table::data.table()}} -> \link[data.table:data.table]{data.table::data.table}\cr
Evaluates all hyperparameter configurations in \code{dt} through resampling, where each configuration is a row, and columns are scalar parameters.
Return a data.table with corresponding rows, where each column is a named measure.
After a batch-eval the \link{Terminator} is checked, if it is positive, an exception of class \code{terminated_message} is raised.
This function should be internally called by the tuner.
\item \code{best(measure = NULL, ties_method = "random")}\cr
(\link{Measure}, \code{character(1)}) -> \link[mlr3:ResampleResult]{mlr3::ResampleResult}\cr
Queries the \link[mlr3:BenchmarkResult]{mlr3::BenchmarkResult} for the best \link[mlr3:ResampleResult]{mlr3::ResampleResult} according \code{measure} (default is the first measure in \code{$measures}).
\code{ties_method} can be "first", "last" or "random".
\item \code{archive(unnest = TRUE)}
\code{logical(1)} -> \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Returns a table of contained resample results, similar to the one returned by \code{\link[mlr3:benchmark]{mlr3::benchmark()}}'s
\code{archive()} method. If \code{unnest} is \code{TRUE}, hyperparameter settings are stored in
separate columns instead of inside a list column.
}
}

\examples{
library(mlr3)
library(paradox)
library(data.table)
# Object required to define the performance evaluator:
task = mlr_tasks$get("iris")
learner = mlr_learners$get("classif.rpart")
resampling = mlr_resamplings$get("holdout")
measures = mlr_measures$mget("classif.ce")
param_set = ParamSet$new(params = list(
  ParamDbl$new("cp", lower = 0.001, upper = 0.1),
  ParamInt$new("minsplit", lower = 1, upper = 10)))

terminator = TerminatorEvals$new(5)
inst = TuningInstance$new(
  task = task,
  learner = learner,
  resampling = resampling,
  measures = measures,
  param_set = param_set,
  terminator = terminator
)
inst$eval_batch(data.table(cp = c(0.05, 0.01), minsplit = c(5, 3)))
inst$archive()
}
\concept{TuningInstance}
\keyword{datasets}
