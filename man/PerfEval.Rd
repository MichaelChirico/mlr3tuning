% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PerfEval.R
\docType{data}
\name{PerfEval}
\alias{PerfEval}
\title{PerfEval Class}
\format{\link[R6:R6Class]{R6::R6Class} object.}
\description{
Implements a performance evaluator for tuning. This class encodes the black box objective function,
that a generic tuner has to optimize. It allows the basic operations of querying the objective
at design points (see \code{eval_batch}), storing the evaluated point in an internal archive
and querying the archive (see \code{archive}).

The performance evaluator is the major input for a \link{Tuner}.

Evaluations of HP configurations are performed in batches, and after a batch-eval, if the \link{Terminator} is positive,
an exception is raised. No further evaluations can be performed from this point on.
}
\section{Construction}{
\preformatted{pe = PerfEval$new(task, learner, resampling, measures, param_set, terminator, store_models = FALSE)
}
\itemize{
\item \code{task} :: \link[mlr3:Task]{mlr3::Task}.
See also \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{learner} :: \link[mlr3:Learner]{mlr3::Learner}.
See also \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{resampling} :: \link[mlr3:Resampling]{mlr3::Resampling}.
See also \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{measures} :: list of \link[mlr3:Measure]{mlr3::Measure}.
See also \link[mlr3:mlr_sugar]{mlr3::mlr_sugar}.
\item \code{param_set} :: \link[paradox:ParamSet]{paradox::ParamSet}.
\item \code{terminator} :: \link{Terminator}.
\item \code{store_models} :: \code{logical(1)}\cr
Keep the fitted learner models? Passed down to \code{\link[mlr3:benchmark]{mlr3::benchmark()}}.
\item \code{start_time} :: \code{POSIXct(1)}\cr
Time the tuning / evaluations were started.
}
}

\section{Fields}{

\itemize{
\item \code{task} :: \link[mlr3:Task]{mlr3::Task}\cr
\item \code{learner} :: \link[mlr3:Learner]{mlr3::Learner}\cr
\item \code{resampling} :: \link[mlr3:Resampling]{mlr3::Resampling}\cr
\item \code{measures} :: list of \link[mlr3:Measure]{mlr3::Measure}\cr
\item \code{param_set} :: \link[paradox:ParamSet]{paradox::ParamSet}\cr
\item \code{terminator} :: \link{Terminator}\cr
\item \code{store_models} :: \code{logical(1)}\cr
\item \code{bmr} :: \link[mlr3:BenchmarkResult]{mlr3::BenchmarkResult}\cr
A benchmark result, container object for all performed \link{ResampleResult}s when evaluating HP configurations.
\item \code{n_evals} :: \code{integer(1)}\cr
Number of unique experiments stored in the container.
}
}

\section{Methods}{

\itemize{
\item \code{eval_batch(dt)}\cr
\code{\link[data.table:data.table]{data.table::data.table()}} -> \link[data.table:data.table]{data.table::data.table}\cr
Evaluates all hyperparameter configurations in \code{dt} through resampling, where each configuration is a row, and columns are scalar parameters.
Return a data.table with corresponding rows, where each column is an named measure.
After a batch-eval the \link{Terminator} is checked, if it is positive, an exception of class \code{terminated_message} is raised.
This function should be internally called by the tuner.
\item \code{best(ties_method = "random")}\cr
(\code{character(1)}) -> \link[mlr3:ResampleResult]{mlr3::ResampleResult}\cr
Queries the \link[mlr3:BenchmarkResult]{mlr3::BenchmarkResult} for the best \link[mlr3:ResampleResult]{mlr3::ResampleResult} according to the first measure in \code{$measures}.
\code{ties_method} can be "first", "last" or "random".
\item \code{archive(unnest = TRUE)}
\code{logical(1)} -> \code{\link[data.table:data.table]{data.table::data.table()}}\cr
Returns a table of contained resample results, similar to the one returned by \code{\link[mlr3:benchmark]{mlr3::benchmark()}}'s
\code{archive()} method. If \code{unnest} is \code{TRUE}, hyperparameter settings are stored in
separate columns instead of inside a list column.
}
}

\examples{
library(mlr3)
library(paradox)
library(data.table)
# Object required to define the performance evaluator:
task = mlr_tasks$get("iris")
learner = mlr_learners$get("classif.rpart")
resampling = mlr_resamplings$get("holdout")
measures = mlr_measures$mget("classif.ce")
param_set = ParamSet$new(params = list(
  ParamDbl$new("cp", lower = 0.001, upper = 0.1),
  ParamInt$new("minsplit", lower = 1, upper = 10)))

terminator = TerminatorEvals$new(5)
pe = PerfEval$new(
  task = task,
  learner = learner,
  resampling = resampling,
  measures = measures,
  param_set = param_set,
  terminator = terminator
)
pe$eval_batch(data.table(cp = c(0.05, 0.01), minsplit = c(5, 3)))
pe$archive()
}
\concept{PerfEval}
\keyword{datasets}
